\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, positioning, calc}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codesilver}{rgb}{0.85,0.85,0.85}
\definecolor{codeblue}{rgb}{0.25,0.41,0.88}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{codesilver},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{magenta},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

\title{Practical Work 1: TCP File Transfer Report}
\author{Student Name: Nguyen Viet Hung \\ Student ID: 23BI14188}

\begin{document}

\maketitle

\section{Goal}
The goal of this practical work is to implement a 1-1 file transfer system over \textbf{TCP/IP} using \textbf{sockets} 
in a Command Line Interface (CLI), based on the provided framework.

\section{Protocol Design}

\subsection{How You Design Your Protocol}
To enable the Server to correctly anticipate and receive the file, the communication protocol is designed in \textbf{two phases}:
\begin{enumerate}
    \item \textbf{Phase 1: Send File Information Header}
    The Client sends a \textbf{single} data packet containing the file metadata structured as a string:
    $$\text{Filename}\vert\text{Filesize\_in\_bytes}$$
    \item \textbf{Phase 2: Send File Data}
    The Client sequentially reads the file in chunks of \texttt{BUFFER\_SIZE} bytes and sends them over the socket until the entire file is transferred.
\end{enumerate}

\subsection{Data Header Structure}
The Client creates a header string (e.g., \texttt{test\_file.txt|12345}), where \texttt{12345} is the exact file size in bytes.
This allows the Server to determine exactly how many bytes to receive before closing the file.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        packet/.style={draw, rectangle, minimum height=1cm, align=center, fill=white},
        arrow/.style={->, >=stealth, thick}
    ]
        \node (client) at (0, 0) {\textbf{Client Stream}};
        
        \node[packet, fill=yellow!20, right=0.5cm of client] (header) {Header\\ \texttt{"filename|filesize"}};
        
        \node[packet, fill=blue!10, right=0.2cm of header] (chunk1) {Data\\Chunk 1};
        \node[packet, fill=blue!10, right=0.2cm of chunk1] (chunk2) {Data\\Chunk 2};
        \node[right=0.2cm of chunk2] (dots) {...};
        \node[packet, fill=blue!10, right=0.2cm of dots] (chunkn) {Data\\Chunk N};
        
        \draw[decoration={brace,mirror,raise=5pt},decorate] 
            (header.south west) -- (header.south east) 
            node [pos=0.5,anchor=north,yshift=-10pt] {Phase 1};
            
        \draw[decoration={brace,mirror,raise=5pt},decorate] 
            (chunk1.south west) -- (chunkn.south east) 
            node [pos=0.5,anchor=north,yshift=-10pt] {Phase 2};

        \draw[arrow] (-2, -0.5) -- (10, -0.5) node[right] {Time / Socket Stream};
        
    \end{tikzpicture}
    \caption{File transfer protocol structure (Header followed by Data)}
    \label{fig:protocol}
\end{figure}


\section{System Organization}

\subsection{How You Organize Your System}
The system is organized into a classic \textbf{Client-Server} model using TCP/IP sockets.
\begin{enumerate}
    \item \textbf{Server (\texttt{server.py}):} A passive component that listens for incoming connections on a predefined address and port (\texttt{127.0.0.1:65432}).
    \item \textbf{Client (\texttt{client.py}):} An active component that initiates the connection to the Server and drives the file transfer process.
\end{enumerate}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[node distance=2cm, auto]
        \tikzstyle{block} = [rectangle, draw, fill=blue!10, text width=6em, text centered, rounded corners, minimum height=3em]
        \tikzstyle{line} = [draw, -latex']
        \tikzstyle{cloud} = [draw, ellipse, fill=red!10, node distance=3cm, minimum height=2em]
        
        \node [block] (server_start) {Server Start};
        \node [block, below of=server_start] (bind) {Bind & Listen\\(65432)};
        \node [block, below of=bind, node distance=2.5cm] (accept) {Accept\\Connection};
        \node [block, below of=accept, node distance=2.5cm] (recv_head) {Receive\\Header};
        \node [block, below of=recv_head] (recv_data) {Receive Data\\(Loop)};
        
        \node [block, right=4cm of server_start] (client_start) {Client Start};
        \node [block, below of=client_start, node distance=4.5cm] (connect) {Connect to\\Server};
        \node [block, below of=connect, node distance=2.5cm] (send_head) {Send\\Header};
        \node [block, below of=send_head] (send_data) {Send Data\\(Loop)};
        
        \path [line] (server_start) -- (bind);
        \path [line] (bind) -- (accept);
        \path [line] (accept) -- (recv_head);
        \path [line] (recv_head) -- (recv_data);
        
        \path [line] (client_start) -- (connect);
        \path [line] (connect) -- (send_head);
        \path [line] (send_head) -- (send_data);
        
        \path [line, dashed, thick] (connect) -- node [above] {TCP Handshake} (accept);
        \path [line, dashed, thick, color=blue] (send_head) -- node [above] {Metadata} (recv_head);
        \path [line, dashed, thick, color=blue] (send_data) -- node [above] {Content} (recv_data);
        
    \end{tikzpicture}
    \caption{File transfer interaction flow}
    \label{fig:flow}
\end{figure}


\section{File Transfer Implementation}

\subsection{How You Implement the File Transfer: Client (\texttt{client.py})}
The Client handles connection, header preparation, and data sending.
\begin{lstlisting}[language=Python, caption=Code Snippet from Client: Sending Header and File Data, numbers=left]
# Get file info
filesize = os.path.getsize(FILE_TO_SEND)
filename = os.path.basename(FILE_TO_SEND)
    
# File info
header = f"{filename}|{filesize}"
s.send(header.encode())
    
print(f"[*] File: {filename}, Size: {filesize} bytes")

# Send file data
bytes_sent = 0
with open(FILE_TO_SEND, "rb") as f:
    while True:
        bytes_read = f.read(BUFFER_SIZE)
        if not bytes_read:
            break
            
        s.sendall(bytes_read)
        bytes_sent += len(bytes_read)
        print(f"\rSent {bytes_sent}/{filesize} bytes", end="")
\end{lstlisting}

\subsection{How You Implement the File Transfer: Server (\texttt{server.py})}
The Server accepts the connection, receives the header, parses the file information, and writes the incoming data to a local file.
\begin{lstlisting}[language=Python, caption=Code Snippet from Server: Receiving Header and File Data, numbers=left]
# File info
received = client_socket.recv(BUFFER_SIZE).decode()
filename, filesize_str = received.split('|')
filesize = int(filesize_str)
filename = os.path.basename(filename)
    
print(f"[*] File: {filename}, Size: {filesize} bytes")

# Receive file data
bytes_received = 0
with open("received_" + filename, "wb") as f:
    while bytes_received < filesize:
        remaining_bytes = filesize - bytes_received
            
        bytes_to_read = min(BUFFER_SIZE, remaining_bytes)
        bytes_read = client_socket.recv(bytes_to_read)
       
        if not bytes_read:
            break
            
        f.write(bytes_read)
        bytes_received += len(bytes_read)
        print(f"\rReceived {bytes_received}/{filesize} bytes", end="")
\end{lstlisting}

\section{Who Does What}

The responsibilities are clearly divided between the Client and the Server:

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Component} & \textbf{Key Responsibilities} \\
        \hline
        \textbf{Server (\texttt{server.py})} & $\bullet$ Creates the socket, binds, and listens on port \texttt{65432}. \\
        & $\bullet$ Accepts the connection from the Client. \\
        & $\bullet$ \textbf{Receives and parses the Header} (\texttt{filename|filesize}). \\
        & $\bullet$ \textbf{Receives file data} in chunks until \texttt{filesize} is reached. \\
        & $\bullet$ Writes the received data to a new file (\texttt{received\_...}). \\
        & $\bullet$ Closes the connections. \\
        \hline
        \textbf{Client (\texttt{client.py})} & $\bullet$ Creates the socket and connects to the Server. \\
        & $\bullet$ Retrieves source file information (\texttt{test\_file.txt}). \\
        & $\bullet$ \textbf{Creates and sends the Header} (\texttt{filename|filesize}). \\
        & $\bullet$ \textbf{Reads and sends file data} in chunks (\texttt{BUFFER\_SIZE}). \\
        & $\bullet$ Closes the connection. \\
        \hline
    \end{tabular}
    \caption{Task Allocation}
\end{table}

\end{document}